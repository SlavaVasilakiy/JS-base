"use strict";

/*
1. Необходимо вывести в консоль массив продуктов в котором есть хоть одна
фотография, используя метод filter. Исходные данные - массив products.
2. Необходимо отсортировать массив products используя метод sort по цене,
начиная с самой маленькой, заканчивая самой большой ценой, после чего вывести
отсортированный массив в консоль.
Если сложно работать с методами массива, то можно сделать и обычным циклом.
*/

const products = [
	{
		id: 3,
		price: 127,
		photos: ["1.jpg", "2.jpg"],
	},
	{
		id: 5,
		price: 499,
		photos: [],
	},
	{
		id: 10,
		price: 26,
		photos: ["3.jpg"],
	},
	{
		id: 8,
		price: 78,
	},
];

// 1. Выводим в консоль отфильтрованный результат исходного массива (условие фильтрации {если в массиве product есть подмассив photos и его длина > 0, тоесть подмассив не пустой})

console.log(
	products.filter((product) => product.photos && product.photos.length > 0),
);

// 2. Всё что я понял из документации (Функция сравнения должна возвращать числовое значение. Если функция сравнения возвращает отрицательное число, то элементы считаются в правильном порядке, и ничего не меняется. Если она возвращает положительное число, то элементы меняются местами. Если она возвращает 0, порядок элементов остается без изменений). Но как она это делает не понятно. `a.price - b.price` конкретно вот эта запись вообще не понятна, ну допустим он вычисляет 127 - 499 = -372 => следовательно 127 идёт первым - это ясно, а потом что ? Это какая-то рекурсивная, цикличная функция ? В документации сказанно что это не цикличная фунция - тогда вообще не ясно что происходит внутри.

// console.log(products.sort((a, b) => a.price - b.price));

// Реализация сортировки пузырьком с использованием деструктуризации
for (let i = 0; i < products.length - 1; i++) {
	let swapped = false;
	for (let j = 0; j < products.length - i - 1; j++) {
		if (products[j].price > products[j + 1].price) {
			// Обмен элементов с использованием деструктуризации
			[products[j], products[j + 1]] = [products[j + 1], products[j]];
			swapped = true;
		}
	}
	// Если на текущей итерации не было обменов, массив уже отсортирован
	if (!swapped) {
		break;
	}
}

console.log(products);
